'''
题目描述：
数轴×有两个点的序列A={A1，A2,…Am}和B={B1,B2,.Bn}，A和Bj均为正整数，A、B已经从小到大排好序，A、B均肯定不为空，给定一个距离R（正整数），列出同时满足如下条件的所有（Ai，Bj）数对
条件
1）Ai <= Bj
2）Ai,Bj 距离小于等于 R，但如果Ai 找不到R范围内的Bj，则列出距它最近的1个Bj，当然此种情况仍然要满足1），但如果仍然找不到，就丢弃Ai

原型：
车路协同场景，一条路上发生了有很多事件（A），要通过很多路测设备（B）广播给路上的车，需要给每个事件找到一个合适的路测设备去发送广播消息。

输入描述：
按照人易读的格式输入一行数据，参见输入样例，其中“ABR={，}”中的每个字符都是关键分割符，输入中无空格，其他均为任意正整数，输入A和B已经排好序，A和B的大小不超过50，正整数范围不会超过65535。

输出描述：
（Ai,Bj）数对序列，排列顺序满足序列中前面的Ax<=后面的Ay，前面的 Bx<=后面的By，因为输入A和B已经排好序，所以实际上输出结果不用特意排序，排序不是考察点。

示例 1
输入
A={1,3,5},B={2,4,6},R=1
输出
(1,2)(3,4)(5,6)
'''

import re
out = re.findall(r'A={(.*)},B={(.*)},R=(\d+)', input())
A = list(map(int, out[0][0].split(',')))
B = list(map(int, out[0][1].split(',')))
R = int(out[0][2])
res = ''
for a in A:
    for b in B:
        if a <= b:
            res += f'({a},{b})'
            break
print(res)

            
